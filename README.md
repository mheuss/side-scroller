# Simple Side Scrolling Game 
_For University of London Intro to Programming Course_

__The application itself is deployed to https://mikeheuss.com. It is always
up-to-date as it auto deploys on commit.__ 

----------

I need to warn you that I didn't just take the boilerplate provided by
the course - I created a React based application, using typescript, and using 
p5 wrapped by React. It was into that framework that I applied the boilerplate
provided by the class.

When you are looking at the code here, you'll see that I've followed what are 
considered best practices in development: the code is broken down into modular
chunks and spread across many files. It is written to be readable and understandable
by humans. I used inheritance to segregate shared functionality and adhere to the 
D.R.Y. principle.

The emphasis is on ease of understanding, maintaining and extending the code. 

I used Typescript instead of Vanilla Javascript - typescript's typing helps
prevent mistakes and makes the code easier to read and understand.

To ease your job of reviewing this work, I've used extensive comments.

------------

### Where to start

You've been given a minified version of the source code - this is because I've
included a number of dependencies that are not part of the standard p5 library
nor the original boilerplate.

So - to properly look at the source - you'll want to use developer tools in
your browser to view source. I've included the source maps, and they'll give
you an easy to read, easy to understand view of the code.

You can also pull down the git repo, or view the code directly in github. 
For that, go to https://github.com/mheuss/side-scroller

All this being said - src/projects/side-scroller.tsx houses the main code. 
Start there.

------------

### Quick directory to aspects of the code

I've added extensive commentary. There is a summary at the top of the various
classes that was autogenerated from the code itself. There are also doc blocks/code 
explanations throughout. These I wrote.

#### Want to see where I handle all low level sprite functionality?

Head on over to `src/models/sprite`.

#### Want to see where I render my character?

Go to `src/models/piece-of-paper`. You will see each character state
separated out by orientation and action, and the draw commands necessary to
render them. 

#### Want to see the rest of the sprites (canyon, cloud, collectable, etc?)

Look in `src/models`. Each sprite has its own file.

#### Want to see how I handle keyboard input and corresponding movement?

___NOTE:___ This game has been implemented to use both the ASW and SPACE for keyboard input, 
as well as LEFT, RIGHT, UP, DOWN and SHIFT. Shift runs, the rest are kind of self- explanatory.

Maybe not so clear is that by holding down the space bar, you'll jump higher.

For keypress:
`src/models/piece-of-paper`, function name `handleKeyPress` and `handleKeyRelease`.  
You'll also see double jumps handled here.

For movement: `src/models/piece-of-paper`, function name `handleMovementAndOrientation`

For jumping/falling: `src/models/piece-of-paper`, function name `isJumpingOrFalling`

#### Want to see how I handle collisions/collecting?

`src/models/piece-of-paper`, function name `checkForInteraction`. 

In `src/models/collectable`, function name `checkGathered`, handles the test for gathering
by calling the collision detection in `src/models/sprite`, and if collided with, sets
that sprites state to collected.

Ideally, of course, that isn't the way it'd work. Rather I'd remove the collectable from
the sprite array. But I am trying to work within the instructions you provided.

#### Want to see how I handled the canyon?

You'll see this in the `src/models/piece-of-paper`, function name `checkForInteraction`.
Right at the top of the function, you'll see IO don't allow the character to move when 
jump, falling or flat out plummeting.

Instead of a bounding box, based on my rendering of the canyon, I look at the pixel the 
character is moving into. If it is the same color as the sky, I know I am in the canyon
and should be falling.

I did things this way because I want to be able to randomize the canyon ledges as well
as the width, and I want to animate them. P5 supports pixel polling. I made use of
that functionality.

------------

### Instructions for running.

The application itself is deployed to https://mikeheuss.com. It is always
up-to-date as it auto deploys on commit.

If you want to run it locally, you need to have `node` installed - and since
you are developers who are knowledgeable in javascript, I am certain you do. 

So - as per the norm `npm install && npm run start` will get things up and running.

