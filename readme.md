# Simple Side Scrolling Game 
_For University of London Intro to Programming Course_

Skip to the &TLDR below if you want to skip the background:

I want to start off by saying that I am a senior software engineer who has been programming
professionally for 30+ years now.

The 90s were a wild time in our profession, with start ups popping up everywhere. 
I dropped out of college three times in those years and joined or started several
new companies. When one of my businesses started making money, well, I never went back.

I had promised myself that I would fix that situation one day. Here I am.

Most of my academic work was so long ago it didn't fly when applying for UoL.
I was admitted on a performance basis, and this is one the classes I've been required 
to take to open up the full range of possibilities.

While I am a full stack developer - I do quite a bit of work in Javascript/Typescript
these days developing web applications in React/Tailwindcss. I've trained numerous
junior developers in how to use javascript, best practices in the industry, etc. 

I used Typescript/React/Tailwind here to scaffold this project. 

So far, I am having a blast. I haven't worked on a video game since the late nineties. At that
time my brother and I were part of a small company that developed software for the nintendo 64. There is
a joy in this kind of development. Thanks for reacquainting me with it. 


----------

### TLDR;

I need to warn you that I didn't just take the boilerplate provided by
the class - I created a React based application, using typescript, and using 
p5 wrapped by React. It was into that framework that I applied the boilerplate
provided by the class.

When you are looking at the code here, you'll see that I've followed what are 
considered best practices in development: the code is broken down into modular
chunks and spread across many files. It is written to be readable and understandable
by humans. I used inheritance to segregate shared functionality and adhere to the 
D.R.Y. principle.

The emphasis is on ease of understanding, maintaining and extending the code. 

I used Typescript instead of Vanilla Javascript - typescript's typing helps
prevent mistakes and makes the code easier to read and understand.

To ease your job of reviewing this work, I've used extensive comments.

------------

### Where to start

src/projects/side-scroller.tsx houses the main code. Start there.

------------

### Quick directory to aspects of the code

I've added extensive commentary. There is a summary at the top of the various
classes that was autogenerated from the code itself. There are also doc blocks/code 
explanations throughout. These I wrote.

#### Want to see where I handle all low level sprite functionality?

Head on over to `src/models/sprite`.

#### Want to see where I render my character?

Go to `src/models/piece-of-paper`. You will see each character state
separated out by orientation and action, and the draw commands necessary to
render them. 

#### Want to see the rest of the sprites (canyon, cloud, collectable, etc?)

Look in `src/models`. Each sprite has its own file.

#### Want to see how I handle keyboard input and corresponding movement?

___NOTE:___ This game has been implemented to use both the ASW and SPACE for keyboard input, 
as well as LEFT, RIGHT, UP, DOWN and SHIFT. Shift runs, the rest are kind of self- explanatory.

For keypress:
`src/models/piece-of-paper`, function name `handleKeyPress` and `handleKeyRelease`.  
You'll also see double jumps handled here.

For movement: `src/models/piece-of-paper`, function name `handleMovementAndOrientation`

For jumping/falling: `src/models/piece-of-paper`, function name `isJumpingOrFalling`

#### Want to see how I handle collisions/collecting?

`src/models/piece-of-paper`, function name `checkForInteraction`. 

In `src/models/collectable`, function name `checkGather`, handles the test for gathering
by calling the collision detection in `src/models/sprite`, and if collided with, sets
that sprites state to collected.

Ideally, of course, that isn't the way it'd work. Rather I'd remove the collectable from
the sprite array. But I am trying to work within the instructions you provided.

#### Want to see how I handled the canyon?

You'll see this in the `src/models/piece-of-paper`, function name `checkForInteraction`.
Right at the top of the function, you'll see IO don't allow the character to move when 
jump, falling or flat out plummeting.

Instead of a bounding box, based on my rendering of the canyon, I look at the pixel the 
character is moving into. If it is the same color as the sky, I know I am in the canyon
and should be falling.

I did things this way because I want to be able to randomize the canyon ledges as well
as the width, and I want to animate these suckers. Since p5 allows for quick pixel polling, 
I went with this method.

------------
### Instructions for running.
------------

The application itself is deployed to https://mikeheuss.com. It is always
up-to-date as it auto deploys on commit.

If you want to run it locally, you need to have node installed - and since
you are developers who are knowledgeable in javascript, I am certain you do. 

So - as per the norm `npm install && npm run start` will get things up and running.

