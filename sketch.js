/*
       WARNING:

        This is transpiled output using tsc, consolidated to a single file so
        I can align with the instructions. The full source is located
        here: https://github.com/mheuss/side-scroller.

        Looking at it this way, as a large javascript file, is unnecessary and not recommended.
        It is harder to read, harder to understand.

        You'd be better off looking at the repo, or in the src directory, and reading
        the README.md file.

        Again, the repo is located at https://github.com/mheuss/side-scroller and
        the README.md file is located in the root. In that read me file, I specifically point you to the portions
        of the code that relate to the different objectives that were assigned.

    STATEMENT ON WHAT I DID AND/OR DID NOT WRITE:

        All the code you see below, I wrote. However, this code has gone through
        a transpilation process. If you'd like to see the code prior to transpilation,
        please refer to the github repo or to the uploaded zip file.

        The summaries in comment blocks before the classes are autogenerated from
        the classes themselves, and from the doc blocks I had provided over each method.

        Other than that, this is all my work.


    RUNNING THE CODE:

      I have this deployed at https://mikeheuss.com. You can see it running there.

      To run this locally, it is easiest to just clone the repo, then, inside the root,
      `npm i`, `npm run start`.


    KEYS:

      Left, right, up, down arrow keys. Shift to run. Holding space bar will jump you
      higher. Tapping is more of a hop.


 */

/*
  The below is autogenerated from the code.

The provided code defines a `Canyon` class in TypeScript that extends the `Sprite` class. This class represents a canyon that a player must jump over within a p5.js-based graphical environment. The canyon can animate by varying its width over time.

Key components of the code:

- **Constants**:
  - `MAX_WIDTH`: Maximum width of the canyon.
  - `MIN_WIDTH`: Minimum width of the canyon.

- **Interface**:
  - `ICrevice`: Specifies the properties of the canyon's crevice width, velocity of width change, and the chance for the width to change.

- **Class Definition**:
  - **Properties**:
    - `crevice`: An object adhering to `ICrevice`, managing the canyon's width, velocity, and change probability.
    - `className`: Identifier for checking interactions, set to "Canyon".

  - **Constructor**: Initializes the canyon with position, scale, and initial width of the crevice, constraining the width between `MIN_WIDTH` and `MAX_WIDTH`.

- **Methods**:
  - **Public Methods**:
    - `setChanceForCreviceWidthChange`: Sets the probability (as a percentage) that the crevice width will change during each draw cycle.
    - `draw`: Main rendering function for the canyon, which also handles potential animation of the canyon's width.

  - **Private Methods**:
    - `shouldCreviceChange`: Determines if the crevice width should change based on the set probability and, if so, updates the width and velocity accordingly. It ensures that the width stays within the defined bounds (`MIN_WIDTH` to `MAX_WIDTH`).

- **Drawing Instructions**:
  - In the `draw` method, various p5.js drawing commands are executed to render both halves of the canyon. The rendering accounts for the width of the crevice and includes drawing the horizon line, filling shapes, and drawing vertices that make up the visual representation of the canyon.

The `Canyon` class extends the functionality of the base `Sprite` class to include dynamic changes to its width, adding an interactive and potentially challenging element to the game environment. The use of p5.js commands within `processArray` enables the dynamic and visually accurate rendering of complex shapes that represent the canyon.
 */
/*
Since i want the width of the canyon to vary, and even to animate opening and closing
at different times, I need to set a max and min width size.
 */
const MAX_WIDTH = 70;
const MIN_WIDTH = 0;
/**
 * This class represents the canyon that the player will have to jump over.
 */
export class Canyon extends Sprite {
  crevice; // Width or spread of the chasm
  className = "Canyon"; // Used for reference when checking for interactions
  /**
   * Initializes the canyon with the given properties.
   * @param p5 - The p5 instance
   * @param x - The x position
   * @param y - The y position
   * @param scale - The scale of the canyon
   * @param crevice - The width of the canyon
   */
  constructor(p5, x, y, scale, crevice = 0) {
    super(p5, x, y, scale ?? 1);
    // Default props
    this.crevice = {
      width: p5.constrain(crevice, MIN_WIDTH, MAX_WIDTH),
      velocity: 0,
      chanceForChange: 0,
    };
  }
  /**
   * When set to a number be 1 and 100, reflects the chance of the crevice width
   * changing during the draw cycle.
   *
   * The speed of the change is random
   * @param chance
   */
  setChanceForCreviceWidthChange = (chance) => {
    this.crevice.chanceForChange = chance;
  };
  /**
   * Private function that will determine if the crevice width should change.
   * If it decides it should, it'll randomly change the velocity of the crevice
   * If the crevice was changing, it could stop.
   */
  shouldCreviceChange = () => {
    const { crevice } = this;
    const changePercent = this.randomInt(0, 100);
    if (changePercent < crevice.chanceForChange) {
      crevice.velocity = (this.randomInt(0, 4) - 2) / 5;
    }
    if (crevice.velocity === 0) {
      return;
    }
    crevice.width += crevice.velocity;
    if (crevice.width >= MAX_WIDTH) {
      crevice.velocity = 0;
      crevice.width = MAX_WIDTH;
    } else if (crevice.width <= MIN_WIDTH) {
      crevice.velocity = 0;
      crevice.width = MIN_WIDTH;
    }
  };
  /**
   * Main draw function.
   */
  draw() {
    const { blueSky, grassGreen, darkerGray, midGray, stoneGray } = colors;
    const { crevice } = this;
    // Check if we are applying animation to this canyon, and if so, animate it.
    this.shouldCreviceChange();
    // We pass the draw commands to the base class to render.
    // Why pass as an array? Because the sprite class will provide mathematic
    // computations to account for scale and position.
    this.processArray([
      // First Spread
      ["stroke", blueSky],
      ["strokeWeight", 1],
      ["noFill"],
      ["line", 0, 0, 158 + crevice.width, 0], //draw a horizon line
      ["noStroke"],
      ["fill", blueSky],
      ["rect", 2, -1, 158 + crevice.width, 200],
      ["fill", darkerGray],
      ["noStroke"],
      ["beginShape"],
      ["vertex", 2, 0],
      ["vertex", 70, 20],
      ["vertex", 50, 150],
      ["vertex", 2, 150],
      ["endShape", this.p5.CLOSE],
      ["fill", midGray],
      ["beginShape"],
      ["vertex", 50, 80],
      ["vertex", 90, 80],
      ["vertex", 50, 210],
      ["endShape", this.p5.CLOSE],
      ["strokeWeight", 1],
      ["fill", grassGreen],
      ["beginShape"],
      ["vertex", 10, 0],
      ["vertex", 15, 0],
      ["vertex", 20, 0],
      ["curveVertex", 40, 5],
      ["curveVertex", 70, 20],
      ["curveVertex", 30, 45],
      ["curveVertex", 90, 75],
      ["curveVertex", 70, 95],
      ["curveVertex", 30, 110],
      ["vertex", 90, 130],
      ["vertex", 15, 200],
      ["endShape", this.p5.CLOSE],
      ["rect", 0, 0, 11, 200],
      ["rect", 158 + crevice.width, 0, 5, 200],
      // Second Half
      ["fill", stoneGray],
      [
        "quad",
        100 + crevice.width,
        10,
        150 + crevice.width,
        100,
        150 + crevice.width,
        140,
        150 + crevice.width,
        10,
      ],
      ["fill", midGray],
      [
        "quad",
        100 + crevice.width,
        100,
        150 + crevice.width,
        150,
        150 + crevice.width,
        170,
        150 + crevice.width,
        100,
      ],
      ["fill", grassGreen],
      ["beginShape"],
      ["vertex", 160 + crevice.width, 0],
      ["curveVertex", 130 + crevice.width, 0],
      ["curveVertex", 100 + crevice.width, 10],
      ["curveVertex", 130 + crevice.width, 35],
      ["curveVertex", 100 + crevice.width, 10],
      ["curveVertex", 130 + crevice.width, 35],
      ["curveVertex", 140 + crevice.width, 80],
      ["curveVertex", 100 + crevice.width, 100],
      ["vertex", 145 + crevice.width, 120],
      ["vertex", 160 + crevice.width, 200],
      ["endShape", this.p5.CLOSE],
      ["noStroke"],
      ["stroke", 0],
      ["strokeWeight", 0.5],
      ["line", 0, 0, 20, 0],
      ["line", 128 + crevice.width, 0, 200 + crevice.width, 0],
    ]);
  }
}

/*
  The below is autogenerated from the code.

The provided code defines a `Cloud` class in TypeScript that extends the `Sprite` class. The class represents a cloud entity in a graphical environment using the p5.js library. The cloud can have different moods, each affecting its behavior and appearance.

Key components of the code:

- **Enum**:
  - `Mood`: Specifies the mood of the cloud, either `Happy` or `Sad`. When in a sad mood, the cloud has the capability to throw lightning (though this is planned for future implementation).

- **Class Definition**:
  - **Properties**:
    - `mood`: Tracks whether the cloud is `Happy` or `Sad`.
    - `chanceOfStrike`: The probability of the cloud throwing lightning when it is sad (0-1000, where 1000 represents 100%).
    - `chanceCounter`: A counter used to manage the timing and occurrence of lightning strikes.
    - `className`: Identifier for the class, set to "Cloud".

  - **Constructor**: Initializes the cloud with position, scale, and initial chance of lightning strike probability.

- **Methods**:
  - **Public Methods**:
    - `setMood`: Sets the cloud's mood (Happy or Sad) and optionally sets the chance of lightning strike.
    - `setChanceOfStrike`: Sets the probability of the cloud throwing lightning.
    - `draw`: Main rendering function that drifts the cloud across the screen and draws it based on its mood.

  - **Private Methods**:
    - `drift`: Moves the cloud leftward across the screen and resets its position once it moves off-screen.
    - `drawHappy`: Contains p5.js commands to draw the cloud in a happy state.
    - `drawSad`: Contains p5.js commands to draw the cloud in a sad state. It also handles the logic for determining whether the cloud throws lightning.

The `Cloud` class manages the rendering and behavior of cloud entities that can drift across the screen. Depending on their mood, they exhibit different visual properties and behaviors, such as the potential to throw lightning when sad. The `draw` method ensures that the cloud's appearance is updated appropriately based on its state.
*/
/**
 * Specifies the mood of the cloud
 */
export var Mood;
(function (Mood) {
  Mood[(Mood["Happy"] = 0)] = "Happy";
  Mood[(Mood["Sad"] = 1)] = "Sad";
})(Mood || (Mood = {}));
/**
 * This class represents a cloud that can be happy or sad. Sad cloud throws lightning,
 * happy cloud just drifts.
 */
export class Cloud extends Sprite {
  mood = Mood.Happy;
  chanceOfStrike; // 0-1000 - when the cloud is sad, it has a chance of striking - 1000 being 100%
  chanceCounter;
  className = "Cloud";
  constructor(p5, x, y, scale, chanceOfStrike = 0) {
    super(p5, x, y, scale ?? 1);
    this.chanceOfStrike = chanceOfStrike;
    this.chanceCounter = 0;
  }
  /**
   * Sets the cloud's mood
   * @param mood The mood to set, i.e. Happy or Sad
   * @param chanceOfStrike The chance of the cloud striking - from 0 to 1000
   */
  setMood(mood, chanceOfStrike = 0) {
    this.mood = mood;
    if (mood === Mood.Sad) {
      this.chanceOfStrike = chanceOfStrike;
    }
  }
  /**
   * Sets the chance of the cloud striking
   * @param chanceOfStrike The chance of the cloud striking - from 0 to 1000
   */
  setChanceOfStrike(chanceOfStrike) {
    this.chanceOfStrike = chanceOfStrike;
  }
  /**
   * Drifts the cloud across the screen
   */
  drift = () => {
    // Let's use scale to determine drift. THe larger the cloud, the faster the drift
    const speed = 0.5 * this.scale * 2;
    this.move(-speed, 0);
    const x = this.getX();
    const y = this.getY();
    if (x < -200) {
      this.setPosition(3000, y);
    }
  };
  /**
   * Draws a happy cloud
   */
  drawHappy = () => {
    // We pass the draw commands to the base class to render.
    // Why pass as an array? Because the sprite class will provide mathematic
    // computations to account for scale and position.
    this.processArray([
      ["stroke", ...colors.cloudBorder],
      ["strokeWeight", 3],
      ["fill", 255],
      ["ellipse", 30, 70, 60, 60],
      ["ellipse", 130, 70, 60, 60],
      ["ellipse", 37, 40, 50, 50],
      ["ellipse", 95, 40, 75, 75],
      ["noStroke"],
      ["rect", 23, 43, 100, 55],
      ["rect", 29, 42, 106, 55],
      ["rect", 14, 42, 50, 25],
      ["rect", 24, 32, 50, 25],
      ["rect", 12, 48, 10, 10],
      ["stroke", ...colors.cloudBorder],
      ["strokeWeight", 3],
      ["line", 30, 100, 130, 100],
      ["stroke", ...colors.cloudBorder],
      ["strokeWeight", 2],
      ["fill", ...colors.cloudBorder],
      ["ellipse", 60, 50, 10, 10],
      ["ellipse", 100, 50, 10, 10],
      ["fill", ...colors.cloudBlush],
      ["ellipse", 50, 70, 12, 12],
      ["ellipse", 110, 70, 12, 12],
      ["stroke", ...colors.cloudBorder],
      ["noFill"],
      ["arc", 80, 55, 20, 0, this.p5.PI],
    ]);
  };
  /**
   * Draws a sad cloud
   */
  drawSad = () => {
    const { chanceOfStrike } = this;
    let cloudFill = 180;
    if (chanceOfStrike) {
      if (this.chanceCounter === 0) {
        const strike = this.randomInt(0, 1000);
        if (strike < chanceOfStrike) {
          this.chanceCounter = 1;
        }
      } else {
        this.chanceCounter++;
        cloudFill = 180 - this.chanceCounter / 3;
        if (this.chanceCounter > 120) {
          this.chanceCounter = 0;
        }
      }
    }
    // We pass the draw commands to the base class to render.
    // Why pass as an array? Because the sprite class will provide mathematic
    // computations to account for scale and position.
    this.processArray([
      ["stroke", ...colors.cloudBorder],
      ["strokeWeight", 3],
      ["fill", cloudFill],
      ["ellipse", 30, 70, 60, 60],
      ["ellipse", 130, 70, 60, 60],
      ["ellipse", 37, 40, 50, 50],
      ["ellipse", 95, 40, 75, 75],
      ["noStroke"],
      ["rect", 23, 43, 100, 55],
      ["rect", 29, 42, 106, 55],
      ["rect", 14, 42, 50, 25],
      ["rect", 24, 32, 50, 25],
      ["rect", 12, 48, 10, 10],
      ["stroke", ...colors.cloudBorder],
      ["strokeWeight", 3],
      ["line", 30, 100, 130, 100],
      ["stroke", ...colors.cloudBorder],
      ["strokeWeight", 2],
      ["fill", ...colors.cloudBorder],
      ["ellipse", 60, 50, 10, 10],
      ["ellipse", 100, 50, 10, 10],
      ["stroke", ...colors.cloudBorder],
      ["noFill"],
      ["arc", 80, 75, 20, this.p5.PI, 0],
      ["strokeWeight", 3],
      ["line", 70, 45, 60, 35],
      ["line", 90, 45, 100, 35],
    ]);
  };
  /**
   * Draws the cloud
   */
  draw = () => {
    this.drift();
    const { mood } = this;
    return mood === Mood.Happy ? this.drawHappy() : this.drawSad();
  };
}

/*
  The below is autogenerated from the code.

  The provided code defines a `Collectable` class in TypeScript that extends the `Sprite` class. This class represents a coin that the player can collect within a p5.js-based graphical environment. The coin can animate its smile to give a dynamic visual effect.

Key components of the code:

- **Constants**:
  - `SMILE_MAX`: Maximum arc for the coin's smile.
  - `SMILE_MIN`: Minimum arc for the coin's smile.

- **Class Definition**:
  - **Properties**:
    - `isFound`: A boolean indicating whether the coin has been collected.
    - `coinColor`: Array representing the color of the coin.
    - `smileArc`: The arc of the coin's smile, initialized randomly within bounds.
    - `transformSmileIncrement`: Increment/decrement value to animate the smile.
    - `className`: Identifier for the class, set to "Collectable".

  - **Constructor**: Initializes the coin with position, scale, and random color and smile arc values.

- **Methods**:
  - **Public Methods**:
    - `checkGather`: Checks if the player's coordinates intersect with the coin's boundaries, marking the coin as collected if true.
    - `draw`: Main rendering function that animates and draws the coin unless it has been collected. It also randomly changes the smile arc at intervals.

  - **Private Methods**:
    - `transformSmile`: Animates the smile arc, ensuring it stays within the defined bounds (`SMILE_MIN` to `SMILE_MAX`), and halts transformation if boundaries are reached.

- **Drawing Instructions**:
  - In the `draw` method, the coin is drawn with various p5.js shapes and commands, including condition for smiling animation. Only non-collected coins are rendered.

The `Collectable` class manages the rendering and behavior of coin entities that can be collected by the player. It includes an animated smiling feature, which adds dynamism and visual appeal to the coin's appearance on the screen. The `draw` method ensures that the coin is only displayed if it has not yet been collected, and it periodically updates the smile to make the coin look more lively.
*/
/*
I want to be able to animate the size of the smile on my coin. So I need to set
a max and min.
 */
const SMILE_MAX = 12;
const SMILE_MIN = 2;
/**
 * This class represents a collectable coin that the player can gather.
 */
export class Collectable extends Sprite {
  isFound = false;
  coinColor;
  smileArc;
  transformSmileIncrement = 0;
  className = "Collectable";
  // Initialize the coin
  constructor(p5, x, y, scale) {
    super(p5, x, y, scale ?? 1, { x: 0, y: 0, h: 150, w: 75 });
    this.coinColor = [
      this.randomInt(210, 255),
      this.randomInt(180, 255),
      this.randomInt(0, 150),
    ];
    this.smileArc = this.randomInt(SMILE_MIN, SMILE_MAX);
  }
  /**
   * Are we within gather range?
   * @param character_x
   * @param character_y
   */
  checkGather = (character_x, character_y) => {
    if (this.collisionCheck(character_x, character_y)) {
      this.isFound = true;
    }
    // @todo We are going to need a redux dispatch function here to update the
    // state with the number of coins collected.
  };
  /**
   * Change the smile.
   */
  transformSmile = () => {
    // Let's do this only once every five frames
    if (this.p5.frameCount % 5 === 0) {
      // Change the smile by the amount we wanna change it
      this.smileArc += this.transformSmileIncrement;
      // If we get outta bounds, let's kill the transformation increment.
      if (this.smileArc > SMILE_MAX || this.smileArc < SMILE_MIN) {
        this.smileArc = this.p5.constrain(this.smileArc, SMILE_MIN, SMILE_MAX);
        this.transformSmileIncrement = 0;
      }
    }
  };
  /**
   * Draw the coin
   */
  draw() {
    // Don't draw if found
    if (this.isFound) {
      return;
    }
    // If we are changing the smile, do that
    if (this.transformSmileIncrement !== 0) {
      this.transformSmile();
    }
    // Every 60 frames, let's possible change the smile
    if (this.p5.frameCount % 60 === 0) {
      if (this.randomInt(0, 10) > 7) {
        this.smileArc === SMILE_MAX
          ? (this.transformSmileIncrement = -1)
          : (this.transformSmileIncrement = 1);
      }
    }
    const { coinOutline, coinHighlight } = colors;
    const { coinColor, smileArc } = this;
    // We pass the draw commands to the base class to render.
    // Why pass as an array? Because the sprite class will provide mathematic
    // computations to account for scale and position.
    this.processArray([
      ["stroke", coinOutline],
      ["fill", coinHighlight],
      ["strokeWeight", 2],
      ["ellipse", 75, 75, 75, 75],
      ["noStroke"],
      ["fill", coinColor],
      ["ellipse", 75, 75, 67, 67],
      ["stroke", coinOutline],
      ["strokeWeight", 2],
      ["fill", coinHighlight],
      ["ellipse", 75, 75, 45, 45],
      ["noStroke"],
      ["fill", coinColor],
      ["ellipse", 75, 75, 39, 39],
      ["fill", coinOutline],
      ["ellipse", 68, 70, 7.5, 7.5], // Left eye
      ["ellipse", 82, 70, 7.5, 7.5], // Right eye
      ["fill", coinHighlight],
      ["noStroke"],
      ["ellipse", 65, 80, 6, 6], // Left dimple
      ["ellipse", 85, 80, 6, 6], // Right dimple
      ["stroke", coinOutline],
      ["fill", coinOutline],
      ["arc", 75, 80, smileArc, 0, this.p5.PI, this.p5.OPEN], // Smile
      ["noStroke"],
      ["fill", 0, 0, 0, 25],
      ["ellipse", 75, 150, 70, 10],
    ]);
  }
}

/*
  The below is autogenerated from the code.

  The provided code defines a `Mountain` class in TypeScript that extends the `Sprite` class. This class represents a mountain range that can consist of one to three mountains, each with its own randomized appearance, within a p5.js-based graphical environment.

Key components of the code:

- **Class Definition**:
  - **Properties**:
    - `drawArray`: An array of p5.js commands used to render the mountains.
    - `className`: Identifier for the class, set to "Mountain".

  - **Constructor**: Initializes the mountain with position, scale, and randomly defined mountains.
    - It creates three potential mountains with varying shades of gray and adds snowy caps with arcs.
    - Each mountain's appearance is randomized within certain color ranges.
    - Uses random percentages to determine which mountains to include in the `drawArray`.
    - Ensures at least one mountain is drawn by default.

- **Methods**:
  - **Public Methods**:
    - `draw`: Main rendering function for the mountain range. It processes the `drawArray` to execute the p5.js commands and render the mountains.

- **Drawing Instructions**:
  - In the constructor:
    - Three sample mountains (`mntn1`, `mntn2`, `mtn3`) are defined using p5.js drawing commands. Each mountain consists of a base triangle and snowy peaks represented by arcs and additional triangles.
    - Randomly decides whether to include each mountain in the final `drawArray` using percentages.
    - Ensures that if no mountains are selected by random chance, all three mountains are included by default.
  - In the `draw` method:
    - Passes the `drawArray` to `processArray` to handle rendering, applying scaling and position computations from the base `Sprite` class.

The `Mountain` class dynamically creates mountain ranges with randomized compositions, adding visual variety and depth to the graphics. The use of p5.js commands in conjunction with the `Sprite` class's rendering capabilities ensures that the mountains are drawn accurately and consistently within the game or application.
*/
/**
 * This class represents a mountain range - 1 to 3 mountains.
 */
export class Mountain extends Sprite {
  drawArray;
  className = "Mountain";
  constructor(p5, x, y, scale) {
    super(p5, x, y, scale ?? 1);
    // Define a random gray, within a given range.
    let stoneColor = this.randomInt(100, 200);
    /*
        In our constructor, we are going to randomly define the mountains that
        this single instance of mountain has. They will be drawn later, but
        I want to get the basics in place now.
         */
    const mntn1 = [
      // 1st Mnt
      ["fill", stoneColor, stoneColor, stoneColor],
      ["noStroke"],
      ["triangle", 28.57, 50, 56.67, 0, 86.67, 50],
      ["fill", 255, 255, 255],
      ["triangle", 46, 18, 56.67, 0, 68, 18],
      ["arc", 48.5, 18, 5, 0, this.p5.PI],
      ["arc", 53, 18, 5, 0, this.p5.PI],
      ["arc", 57, 18, 5, 0, this.p5.PI],
      ["arc", 61, 18, 5, 0, this.p5.PI],
      ["arc", 65.2, 18, 5, 0, this.p5.PI],
    ];
    // Do it again
    stoneColor = this.randomInt(100, 200);
    const mntn2 = [
      // Second mnt
      ["fill", stoneColor, stoneColor, stoneColor],
      ["triangle", 0, 50, 34.29, 12, 82.86, 50],
      ["fill", 255, 255, 255],
      ["triangle", 28.5, 18, 34.29, 12, 42, 18],
      ["arc", 31, 18, 5, 0, this.p5.PI],
      ["arc", 35.5, 18, 5, 0, this.p5.PI],
      ["arc", 39.5, 18, 5, 0, this.p5.PI],
    ];
    // And again
    stoneColor = this.randomInt(100, 200);
    const mtn3 = [
      // 3rd mountain
      ["fill", stoneColor, stoneColor, stoneColor],
      ["triangle", 53.3, 50, 76.67, 11, 100, 50],
      ["fill", 255, 255, 255],
      ["noStroke"],
      ["triangle", 72.5, 18, 76.67, 11, 81, 18],
      ["arc", 75, 18, 5, 0, this.p5.PI],
      ["arc", 78.5, 18, 5, 0, this.p5.PI],
    ];
    // I wanna remove the stroke
    this.drawArray = [["noStroke"]];
    // 30% chance of first mountain
    if (this.randomInt(1, 10) > 7) {
      // Use the spread operator to add the draw commands to the array
      this.drawArray = [...this.drawArray, ...mntn1];
    }
    // 40% chance of second mountain
    if (this.randomInt(1, 10) > 6) {
      // Use the spread operator to add the draw commands to the array
      this.drawArray = [...this.drawArray, ...mntn2];
    }
    // 40% chance of third mountain
    if (this.randomInt(1, 10) > 6) {
      // Use the spread operator to add the draw commands to the array
      this.drawArray = [...this.drawArray, ...mtn3];
    }
    // If no mountains added, add them all
    if (this.drawArray.length === 1) {
      // Add everything. Just throw it all at it.
      this.drawArray = [...this.drawArray, ...mntn1, ...mntn2, ...mtn3];
    }
  }
  /**
   * Do the drawing
   */
  draw() {
    // We pass the draw commands to the base class to render.
    // Why pass as an array? Because the sprite class will provide mathematic
    // computations to account for scale and position.
    this.processArray(this.drawArray);
  }
}

/**
 * An enum just to clarify the orientation of the model. Easier to read than
 * `magic numbers`. Hard coding magic numbers is what we call `code smell`.
 */
export var Orientation;
(function (Orientation) {
  Orientation[(Orientation["LEFT"] = 0)] = "LEFT";
  Orientation[(Orientation["RIGHT"] = 1)] = "RIGHT";
  Orientation[(Orientation["UP"] = 2)] = "UP";
  Orientation[(Orientation["DOWN"] = 3)] = "DOWN";
})(Orientation || (Orientation = {}));
/**
 * An enum just to clarify the action of the model. Easier to read than
 * `magic numbers`. Hard coding magic numbers is what we call `code smell`.
 */
export var Action;
(function (Action) {
  Action[(Action["STANDING"] = 0)] = "STANDING";
  Action[(Action["JUMPING"] = 1)] = "JUMPING";
  Action[(Action["WALKING"] = 2)] = "WALKING";
  Action[(Action["PLUMMETING"] = 3)] = "PLUMMETING";
})(Action || (Action = {}));
/**
 * At some point here, I am going to have a mouse controlled game, in addition to keyboard
 * depending on what a person chooses from a future loading screen.
 *
 * This enum is to clarify how the piece of paper is gonna be controlled
 */
export var ControlledBy;
(function (ControlledBy) {
  ControlledBy[(ControlledBy["KEYBOARD"] = 0)] = "KEYBOARD";
  ControlledBy[(ControlledBy["MOUSE"] = 1)] = "MOUSE";
})(ControlledBy || (ControlledBy = {}));
// Set our constants
const JUMP_INCREMENT = 10; // Fast Jump
const MAX_JUMP_HEIGHT = 250; // Let's not go overboard
const MAX_WALK_HEIGHT = 356; // Let's not walk up into the sky
/**
 * Here is our class. It extends Sprite class, which is a class that is used to
 * render objects on the screen.
 *
 * This class defines the various shapes that can be rendered, as well as the current
 * orientation and action of the model.
 */
export class PieceOfPaper extends Sprite {
  currentOrientation;
  currentAction;
  modelData;
  controlledBy = ControlledBy.KEYBOARD;
  // Added variables for 3a
  // This isn't the best way to do this - but it is the way UoL wants this done.
  // It is unwieldy code - and not very clean
  isJumping = false;
  isFalling = false;
  isLeft = false;
  isRight = false;
  isUp = false; // Added because I want to support up and down
  isDown = false;
  jumpHeight = 0; // Keeps track of, well, jump height
  isRunning = false;
  isPlummeting = false;
  /**
   * The constructor for the class. It sets the orientation and action of the model
   * @param p5 A reference to the p5 base class
   * @param x The x coordinate of the sprite
   * @param y The y coordinate of the sprite
   * @param scale The scale of the sprite. Scaling is used to render distant objects
   * smaller.
   */
  constructor(p5, x, y, scale) {
    const bounds = {
      x: 0,
      y: 0,
      w: 100,
      h: 200,
    };
    super(p5, x, y, scale ?? 1, bounds);
    this.currentOrientation = Orientation.DOWN;
    this.currentAction = Action.STANDING;
    this.modelData = this.buildModels();
    this.controlledBy = ControlledBy.KEYBOARD;
  }
  /**
   * Set how this model is controlled
   * @param controlledBy Enum specifying control by mouse or keyboard
   */
  setControlledBy = (controlledBy) => {
    this.controlledBy = controlledBy;
  };
  /**
   * Actually goes and gets all permutations of a model
   * so when it comes time to render a given model doing
   * a given action, we just look up the results.
   *
   * This takes more memory, its true. But it removes the conditionals
   * when it comes time to render, and allows us to just use a look up
   * table
   */
  buildModels = () => {
    const workingModelData = {
      models: [],
    };
    // The intention here is as follows:
    // We are going to cycle through the possible orientations and
    // actions to build the models
    // Get the orientations. Enum keys are stored by both the index number
    // and the user-friendly strings. We want to filter out the user friendly
    // strings
    const orientations = Object.keys(Orientation).filter((value) =>
      isNaN(Number(value)),
    );
    // Now - create all the models needed to render a person drawn on a
    // piece of paper.
    const actions = Object.keys(Action).filter((value) => isNaN(Number(value)));
    //@ todo: We are going to add a different level - the level that'll provide character animation
    // When we do, we'll have yet another level that'll define the frames and the period
    // of time they are drawn for.
    // We want to iterate over the enum for actions
    actions.forEach((_key, actionIndex) => {
      // Initialize the working data with an empty action
      workingModelData.models[actionIndex] = {
        data: [],
      };
      // Initialize the orientation data
      orientations.forEach((_key, orientationIndex) => {
        workingModelData.models[actionIndex].data[orientationIndex] = {
          data: [],
        };
        // Now get the actual model
        workingModelData.models[actionIndex].data[orientationIndex].data.push(
          ...this.assembleModel(orientationIndex, actionIndex),
        );
      });
    });
    // Return all that data so it can get saved in the member variable.
    return workingModelData;
  };
  /**
   * Sets the orientation of the model (UP, DOWN, LEFT, RIGHT)
   * @param orientation
   */
  setOrientation(orientation) {
    this.currentOrientation = orientation;
  }
  /**
   * Sets the action of the model (STANDING, JUMPING, WALKING)
   * @param action
   */
  setAction(action) {
    this.currentAction = action;
  }
  /**
   * For draw priority, we need to adjust for jumping and falling
   */
  getCalculatedY = () => {
    if (this.isJumping) {
      return this.getBottomY() + this.jumpHeight;
    }
    if (this.isFalling) {
      return this.getBottomY() + this.jumpHeight;
    }
    return this.getBottomY();
  };
  /**
   * This returns an array that represents the shape of a jagged rip of notebook paper
   * @param offset The offset is used to allow this to be rendered n times - but for our
   * purposes, once with a black fill, and once with a white fill.
   */
  jaggedShape = (offset = 0) => {
    return [
      ["beginShape"],
      ["vertex", offset, offset],
      ["vertex", 100 + offset, offset],
      ["vertex", 100 + offset, 200 + offset],
      ["vertex", 83 + offset, 180 + offset],
      ["vertex", 73 + offset, 190 + offset],
      ["vertex", 66 + offset, 172 + offset],
      ["vertex", 63 + offset, 190 + offset],
      ["vertex", 58 + offset, 199 + offset],
      ["vertex", 53 + offset, 180 + offset],
      ["vertex", 39 + offset, 175 + offset],
      ["vertex", 23 + offset, 200 + offset],
      ["vertex", 18 + offset, 190 + offset],
      ["vertex", 10 + offset, 186 + offset],
      ["vertex", offset, 180 + offset],
      ["vertex", 10 + offset, 172 + offset],
      ["vertex", 20 + offset, 153 + offset],
      ["vertex", offset, 146 + offset],
      ["vertex", 20 + offset, 139 + offset],
      ["vertex", 10 + offset, 127 + offset],
      ["vertex", 20 + offset, 113 + offset],
      ["vertex", 15 + offset, 98 + offset],
      ["vertex", offset, 72 + offset],
      ["vertex", 10 + offset, 48 + offset],
      ["vertex", 5 + offset, 30 + offset],
      ["endShape", this.p5.CLOSE],
    ];
  };
  /**
   * This will return the angle between two points. I'm gonna use this to allow my
   * character to always face the mouse pointer.
   *
   * This may be rendered moot by future assignments, however I like it for now.
   * @param x2
   * @param y2
   */
  angleBetweenPoints = (x2, y2) => {
    const x = this.getX();
    const y = this.getY();
    const deltaX = x2 - x;
    const deltaY = y2 - y;
    return Math.atan2(deltaY, deltaX);
  };
  /**
   * This will provide an array of instructions that can be used to render
   * a jumping person, depending on his orientation
   * @param orientation
   * @returns any[][]
   */
  jumpingPerson = (orientation) => {
    const person = [];
    if (orientation === Orientation.UP || orientation === Orientation.DOWN) {
      person.push(
        ["noFill"],
        ["stroke", 30, 30, 30],
        ["circle", 60, 60, 40],
        ["line", 60, 80, 60, 140],
        // Legs
        ["line", 60, 140, 85, 135],
        ["line", 85, 135, 80, 155],
        ["line", 60, 140, 45, 135],
        ["line", 45, 135, 40, 160],
        // Arms
        ["line", 60, 100, 45, 120],
        ["line", 45, 120, 40, 110],
        ["line", 60, 100, 85, 120],
        ["line", 85, 120, 100, 110],
      );
      if (orientation === Orientation.DOWN) {
        person.push(
          ["fill", 0],
          ["circle", 55, 55, 2],
          ["circle", 65, 55, 2],
          ["noFill"],
          ["strokeWeight", 1],
          ["line", 50, 65, 70, 65],
        );
      }
      return person;
    }
    if (orientation === Orientation.LEFT) {
      person.push(
        ["noFill"],
        ["stroke", 30, 30, 30],
        ["circle", 60, 40, 40],
        // Torso
        ["line", 60, 60, 60, 120],
        //Legs
        ["line", 60, 120, 40, 135],
        ["line", 40, 135, 46, 150],
        ["line", 60, 120, 72, 145],
        ["line", 72, 145, 84, 170],
        // Arms
        ["line", 60, 80, 40, 75],
        ["line", 40, 75, 36, 53],
        ["line", 60, 80, 66, 100],
        ["line", 66, 100, 74, 120],
        ["circle", 50, 35, 2],
        ["line", 40, 45, 50, 50],
        ["stroke", colors.lightGray],
        ["line", 80, 65, 90, 85],
        ["line", 30, 80, 40, 100],
        ["line", 45, 160, 55, 180],
        ["line", 90, 135, 100, 155],
      );
    } else {
      person.push(
        ["noFill"],
        ["stroke", 30, 30, 30],
        ["circle", 60, 40, 40],
        // Torso
        ["line", 60, 60, 60, 120],
        ["line", 60, 120, 56, 145],
        ["line", 56, 145, 46, 170],
        ["line", 60, 120, 72, 105],
        ["line", 72, 105, 60, 150],
        ["line", 60, 80, 76, 60],
        ["line", 76, 60, 88, 30],
        ["line", 60, 80, 42, 100],
        ["line", 42, 100, 34, 120],
        ["circle", 70, 35, 2],
        ["line", 80, 45, 65, 50],
        ["stroke", colors.lightGray],
        ["line", 30, 45, 20, 65],
        ["line", 30, 75, 20, 95],
        ["line", 90, 105, 80, 125],
        ["line", 90, 135, 80, 155],
      );
    }
    return person;
  };
  /**
   * This will provide an array of instructions that can be used to render
   * a standing person, depending on his orientation
   * @param orientation
   * @returns any[][]
   */
  standingPerson = (orientation) => {
    const person = [];
    if (orientation === Orientation.UP || orientation === Orientation.DOWN) {
      person.push(
        ["noFill"],
        ["stroke", 30, 30, 30],
        ["circle", 60, 40, 40],
        ["line", 60, 60, 60, 120],
        ["line", 60, 120, 55, 145],
        ["line", 55, 145, 50, 170],
        ["line", 60, 120, 65, 145],
        ["line", 60, 120, 70, 170],
        ["line", 60, 80, 55, 100],
        ["line", 60, 80, 50, 120],
        ["line", 60, 80, 65, 100],
        ["line", 60, 80, 70, 120],
      );
      if (orientation === Orientation.DOWN) {
        person.push(
          ["fill", 0],
          ["circle", 55, 35, 2],
          ["circle", 65, 35, 2],
          ["noFill"],
          ["arc", 60, 45, 20, 0, this.p5.PI],
        );
      }
      return person;
    }
    // So, if we are here, then left and right are it
    if (orientation === Orientation.LEFT) {
      person.push(
        ["noFill"],
        ["stroke", 30, 30, 30],
        ["circle", 60, 40, 40],
        ["line", 60, 60, 60, 120],
        ["line", 60, 120, 56, 145],
        ["line", 56, 145, 56, 170],
        ["line", 60, 120, 62, 145],
        ["line", 62, 145, 64, 170],
        ["line", 60, 80, 56, 100],
        ["line", 56, 100, 36, 103],
        ["line", 60, 80, 66, 100],
        ["line", 66, 100, 64, 120],
        ["circle", 50, 35, 2],
        ["arc", 40, 45, 20, this.p5.PI + 3.3, this.p5.PI - 2.1],
      );
    } else {
      person.push(
        ["noFill"],
        ["stroke", 30, 30, 30],
        ["circle", 60, 40, 40],
        ["line", 60, 60, 60, 120],
        ["line", 60, 120, 66, 145],
        ["line", 66, 145, 66, 170],
        ["line", 60, 120, 62, 145],
        ["line", 62, 145, 58, 170],
        ["line", 60, 80, 56, 100],
        ["line", 56, 100, 58, 116],
        ["line", 60, 80, 62, 100],
        ["line", 62, 100, 64, 120],
        ["circle", 70, 35, 2],
        ["arc", 80, 45, 20, this.p5.PI - 1, this.p5.PI - 0.2],
      );
    }
    return person;
  };
  /**
   * This will call the appropriate methods to return array of instructions
   * that can be used to render a person, depending on his orientation and action
   * @param orientation
   * @param action
   * @returns any[][]
   */
  person(orientation, action) {
    if (action === Action.JUMPING) {
      return this.jumpingPerson(orientation);
    }
    return this.standingPerson(orientation);
  }
  /**
   * This will return an array of instructions that can be used to render a piece of paper
   * with lines and a shadow
   */
  paper = () => {
    return [
      ["fill", 0, 0, 0, 80],
      ["noStroke"],
      ...this.jaggedShape(0),
      ["fill", 255],
      ["noStroke"],
      ...this.jaggedShape(4),
      ["strokeWeight", 2],
      ["stroke", 80, 140, 250, 40],
      ["line", 30, 0, 104, 8],
      ["line", 9, 20, 104, 28],
      ["line", 9, 40, 104, 48],
      ["line", 7, 60, 104, 68],
      ["line", 5, 80, 104, 88],
      ["line", 16, 100, 104, 108],
      ["line", 16, 120, 104, 128],
      ["line", 22, 140, 104, 148],
      ["line", 18, 160, 104, 168],
      ["line", 8, 180, 104, 188],
      ["strokeWeight", 1],
    ];
  };
  /**
   * This function is used to build the lookup table that we will use during the
   * draw cycle to render the model, one piece at a time.
   * @param orientation
   * @param action
   */
  assembleModel = (orientation, action) => {
    switch (action) {
      case Action.STANDING:
        return [...this.paper(), ...this.person(orientation, action)];
      default:
        return [...this.paper()];
      case Action.JUMPING:
        return [...this.paper(), ...this.person(orientation, action)];
    }
  };
  /**
   * Handles key presses
   * @todo I need to also implement UoL keys
   */
  handleKeyPress = () => {
    // Let's not do anything if we are jumping or falling
    if (this.isJumping || this.isFalling || this.isPlummeting) {
      return;
    }
    const keyCode = this.p5.keyCode;
    const key = this.p5.key;
    if (keyCode === this.p5.LEFT_ARROW || key.toLowerCase() === "a") {
      this.isLeft = true;
      this.isRight = false;
    } else if (keyCode === this.p5.RIGHT_ARROW || key.toLowerCase() === "s") {
      this.isRight = true;
      this.isLeft = false;
    } else if (keyCode === this.p5.UP_ARROW) {
      this.isUp = true;
      this.isDown = false;
    } else if (keyCode === this.p5.DOWN_ARROW) {
      this.isDown = true;
      this.isUp = false;
    } else if (keyCode === 16) {
      this.isRunning = true;
    } else if (
      (keyCode === 32 || key.toLowerCase() === "w") &&
      !this.isJumping &&
      !this.isFalling
    ) {
      this.isJumping = true;
      this.jumpHeight = 0;
    } else {
      console.log("Unhandled: ", keyCode);
    }
  };
  /**
   * Handles key releases
   */
  handleKeyRelease = () => {
    const keyCode = this.p5.keyCode;
    const key = this.p5.key;
    if (this.isPlummeting) {
      return;
    }
    // This should be a switch statement, but the criteria is asking
    // for if statements, so here we go.
    if (keyCode === this.p5.LEFT_ARROW || key.toLowerCase() === "a") {
      this.isLeft = false;
    } else if (keyCode === this.p5.RIGHT_ARROW || key.toLowerCase() === "s") {
      this.isRight = false;
    } else if (keyCode === this.p5.UP_ARROW) {
      this.isUp = false;
    } else if (keyCode === this.p5.DOWN_ARROW) {
      this.isDown = false;
    } else if (keyCode === 16) {
      this.isRunning = false;
    } else if (keyCode === 32 || key.toLowerCase() === "w") {
      this.isJumping = false;
      this.isFalling = true;
    }
  };
  /**
   * Handle logic associated with jumping or falling.
   */
  isJumpingOrFalling = () => {
    let y = 0;
    if (!this.isJumping && !this.isFalling) {
      return 0;
    }
    if (this.isJumping) {
      // const jump increment
      this.jumpHeight += JUMP_INCREMENT;
      // Let's max our jump height
      if (this.jumpHeight > MAX_JUMP_HEIGHT) {
        this.isJumping = false;
        this.isFalling = true;
      }
      y -= JUMP_INCREMENT;
    }
    // Take care of falling
    else if (this.isFalling) {
      this.jumpHeight -= JUMP_INCREMENT;
      if (this.jumpHeight <= 0) {
        this.jumpHeight = 0;
        this.isFalling = false;
      }
      y += JUMP_INCREMENT;
    }
    return y;
  };
  /**
   * This function will handle the movement and orientation of the piece of paper
   */
  handleMovementAndOrientation = () => {
    // Get x ready to go
    let x = 0;
    // Calculate our prospective speed
    let movement_increment = this.isRunning ? 2.5 : 1;
    // Now initialize y and get any vector from jumping
    let y = this.isJumpingOrFalling();
    // If we are plummeting - do it and fast
    if (this.isPlummeting) {
      x = 0;
      y += movement_increment * 7;
    }
    // Handle when moving at diagonals. Since they'll be moving both up/down and left/right
    // simultanously, we need to half the speed to keep the same speed, if you
    // know what I am saying.
    // And if you don't, hell, man, words are hard. Just trust me, it has to be done.
    if (
      (this.isUp && (this.isLeft || this.isRight)) ||
      (this.isDown && (this.isLeft || this.isRight))
    ) {
      movement_increment /= 2;
    }
    // Handle left and right
    if (this.isLeft) {
      x -= movement_increment;
      this.setOrientation(Orientation.LEFT);
    } else if (this.isRight) {
      x += movement_increment;
      this.setOrientation(Orientation.RIGHT);
    }
    // If y is zero, then we aren't jumping or falling
    // so handle the up and down
    if (y === 0) {
      if (this.isUp) {
        y -= movement_increment;
        this.setOrientation(Orientation.UP);
      } else if (this.isDown) {
        y += movement_increment;
        this.setOrientation(Orientation.DOWN);
      }
    }
    // do some things if we are jumping or falling
    if (this.isJumping || this.isFalling) {
      // Set animation to jumping
      this.setAction(Action.JUMPING);
    } else {
      // We are standing. Set animation to standing
      this.setAction(Action.STANDING);
      // Let's be sure we don't walk to high up on the screen
      if (this.getY() < MAX_WALK_HEIGHT && y < 0) {
        y = 0;
      }
    }
    // Send the move vectors to the underlying sprint class
    this.move(x, y);
  };
  /**
   * Let's take in an argument of all objects that can be interacted with
   * and loop through them. If we are touching one, we'll do something
   * @param objects An array of objects that can be interacted with
   */
  checkForInteraction(objects) {
    // If we are jumping, this stuff doesn't count
    if (this.isJumping || this.isFalling || this.isPlummeting) {
      return;
    }
    // Now, let's check for interactions
    objects.forEach((object) => {
      switch (object.className) {
        default:
        case "Canyon": {
          // By Default, do nothing
          // Canyons are short-circuited and are happening below
          break;
        }
        case "Collectable": {
          object.checkGather(this.getX(), this.getBottomY());
          break;
        }
      }
      // If we are directly over sky, we've messed up somehow. Maybe canyon,
      // maybe something more devious. Let's plummet
      // Get the color of the bottom middle of our piece of paper
      const hoveringColor = this.p5.get(this.getCenterX(), this.getBottomY());
      // Check to be sure that the arrays called colors.blueSky and hoveringColor
      // have the same entries in the same order
      if (
        colors.blueSky.every((value, index) => value === hoveringColor[index])
      ) {
        this.isPlummeting = true;
        this.isDown = true;
        this.isLeft = false;
        this.isUp = false;
        this.isRight = false;
      }
    });
  }
  /**
   * This is the draw method for the piece of paper. It will render the model
   * with the correct orientation and action
   */
  draw() {
    // Do I calculate the orientation based on the mouse position?
    if (ControlledBy.MOUSE === this.controlledBy) {
      // Get me some radians
      const radians = this.angleBetweenPoints(this.p5.mouseX, this.p5.mouseY);
      // Let's compute the orientation. Since the anchoring of the sprite isn't dead in
      // the middle, we need to alter our radian thresholds just a bit.
      if (radians > 0 && radians < 0.96) {
        this.setOrientation(Orientation.RIGHT);
      } else if (radians >= 0.96 && radians <= 1.76) {
        this.setOrientation(Orientation.DOWN);
      } else if (radians > 1.76 || radians < -2.23) {
        this.setOrientation(Orientation.LEFT);
      } else {
        this.setOrientation(Orientation.UP);
      }
    }
    // Get the model data. This is all precalculated and will render quickly
    // by the use of the lookup table.
    const modelData =
      this.modelData.models[this.currentAction].data[this.currentOrientation]
        .data;
    // We pass the draw commands to the base class to render.
    // Why pass as an array? Because the sprite class will provide mathematic
    // computations to account for scale and position.
    this.processArray(modelData);
  }
}

/**
 * This class represents a sprite that can be drawn on the canvas. It has a position,
 * scale, and bounds for collision detection.
 *
 * This class is meant to be extended. It has a draw method that is meant to be
 * overridden by the child class.
 *
 * When the child class passes draw commands in, we will scale and offset them
 * as appropriate.
 */
export class Sprite {
  x;
  y;
  p5;
  scale;
  bounds;
  className = "Sprite";
  /**
   * Constructor for the Sprite class
   * @param p5 A reference to the p5 base class
   * @param x The x coordinate of the sprite
   * @param y The y coordinate of the sprite
   * @param scale The scale of the sprite
   * @param bounds The bounds of the sprite. This is used for collision detection
   */
  constructor(p5, x, y, scale, bounds = null) {
    this.x = x;
    this.y = y;
    this.p5 = p5;
    this.scale = scale;
    this.bounds = bounds;
  }
  /**
   * This method just wraps p5 random number for convenience
   */
  randomInt = (min, max) => Math.floor(this.p5.random(min, max));
  /**
   * When given the characters coordinates, are we colliding?
   * @param character_x Character's X coord.(leftmost x)
   * @param character_y Character's Y coord.(bottom most y)
   */
  collisionCheck(character_x, character_y) {
    // We can't use the distance function, I don't think - because
    // we are worried about X and Y within the context of a fake z.
    // So - old school math it is.
    return (
      character_x > this.x && // Left Side
      character_x < this.getRightmostX() && // Right Side
      Math.abs(character_y - this.getBottomY()) < 5 // Base of the sprite
    );
  }
  /**
   * Returns the leftmost x
   */
  getX = () => this.x;
  /**
   * Returns the camera adjusted x
   */
  getCameraAdjustedX = () => {
    return this.getX() - this.p5.width / 2;
  };
  /**
   * Gets the x coordinate halfway through the sprite
   */
  getCenterX = () => {
    if (!this.bounds) {
      return this.x;
    }
    const scaledWidth = this.bounds.w * this.scale + this.bounds.x * this.scale;
    return this.x + scaledWidth / 2;
  };
  /**
   * Returns the rightmost x
   */
  getRightmostX = () => {
    if (!this.bounds) {
      return this.x;
    }
    const scaledWidth = this.bounds.w * this.scale + this.bounds.x * this.scale;
    return this.x + scaledWidth;
  };
  /**
   * Gets the bottom most y coordinate of the sprite
   */
  getBottomY = () => {
    // No bounding box. Just return the y
    if (!this.bounds) {
      return this.y;
    }
    // Do we have an offset for x or y?
    const scaledHeight =
      this.bounds.h * this.scale + this.bounds.y * this.scale;
    return this.y + scaledHeight;
  };
  /**
   * Returns the topmost y coordinate of the sprite
   */
  getY = () => this.y;
  /**
   * Moves the sprint in the x and y direction
   * @param x X coord
   * @param y Y coord
   */
  move = (x, y) => {
    this.x = x + this.x;
    this.y = y + this.y;
  };
  /**
   * Sets the position absolutely on the board
   *
   * @param x X coord
   * @param y Y coord
   */
  setPosition = (x, y) => {
    this.x = x;
    this.y = y;
  };
  /**
   * When given an array of p5 commands, we will process them in order, applying
   * scale and offsets as needed.
   *
   * @param graphicData Array of p5 commands
   */
  processArray = (graphicData) => {
    // For now, let's do a forEach loop to process the array
    graphicData.forEach((shape) => {
      // This can be done better. But for now, let's just get it working
      const { x, y, scale } = this;
      const [command, ...args] = shape;
      // Switch on the command, find the transformation, and apply it
      switch (command) {
        // Sanity
        default: {
          alert(
            "Hey Mike! You forgot to implement " +
              command +
              " in the Sprite class!",
          );
          break;
        }
        // Arc
        case "arc": {
          const [x1, y1, d, start, stop] = args;
          this.p5.arc(
            x + scale * x1,
            y + scale * y1,
            scale * d,
            scale * d,
            start,
            stop,
          );
          break;
        }
        // Begin Shape
        case "beginShape":
          this.p5.beginShape();
          break;
        // Background
        case "background": {
          const [r, g, b] = args;
          this.p5.background(r, g, b);
          break;
        }
        // Circle
        case "circle": {
          const [x1, y1, d] = args;
          this.p5.circle(x + scale * x1, y + scale * y1, scale * d);
          break;
        }
        // CurveVertex
        case "curveVertex": {
          const [x1, y1] = args;
          this.p5.curveVertex(x + scale * x1, y + scale * y1);
          break;
        }
        // Ellipse
        case "ellipse": {
          const [x1, y1, w, h] = args;
          this.p5.ellipse(x + scale * x1, y + scale * y1, scale * w, scale * h);
          break;
        }
        // End Shape
        case "endShape":
          this.p5.endShape(...args);
          break;
        // Fill
        case "fill":
          this.p5.fill(...args);
          break;
        // Line
        case "line": {
          const [x1, y1, x2, y2] = args;
          this.p5.line(
            x + scale * x1,
            y + scale * y1,
            x + scale * x2,
            y + scale * y2,
          );
          break;
        }
        // No Fill
        case "noFill":
          this.p5.noFill();
          break;
        // No Stroke
        case "noStroke":
          this.p5.noStroke();
          break;
        // Point
        case "point": {
          const [x1, y1] = args;
          this.p5.point(x + scale * x1, y + scale * y1);
          break;
        }
        // Quad
        case "quad": {
          const [x1, y1, x2, y2, x3, y3, x4, y4] = args;
          this.p5.quad(
            x + scale * x1,
            y + scale * y1,
            x + scale * x2,
            y + scale * y2,
            x + scale * x3,
            y + scale * y3,
            x + scale * x4,
            y + scale * y4,
          );
          break;
        }
        // Rect
        case "rect": {
          const [x1, y1, w, h] = args;
          this.p5.rect(x + scale * x1, y + scale * y1, scale * w, scale * h);
          break;
        }
        // Stroke
        case "stroke":
          this.p5.stroke(...args);
          break;
        // Stroke Weight
        case "strokeWeight":
          this.p5.strokeWeight(...args);
          break;
        //  Triangle
        case "triangle": {
          const [x1, y1, x2, y2, x3, y3] = args;
          this.p5.triangle(
            x + scale * x1,
            y + scale * y1,
            x + scale * x2,
            y + scale * y2,
            x + scale * x3,
            y + scale * y3,
          );
          break;
        }
        // Vertex
        case "vertex": {
          const [x1, y1] = args;
          this.p5.vertex(x + scale * x1, y + scale * y1);
          break;
        }
      }
    });
  };
  /**
   * Stubbed in draw command. This method is here because I want to catch any
   * classes that don't implement their own draw method.
   *
   * I make mistakes. I like to catch them before you do.
   */
  draw() {
    const { fill, stroke, strokeWeight, text } = this.p5;
    // Generic Drawing
    fill(255);
    stroke(0);
    strokeWeight(1);
    text("Draw not implemented!", 10, 10);
  }
}

/**
 * This class represents a tree that can have a randomized canopy.
 */
export class Tree extends Sprite {
  randomizedElements = {
    backgroundCanopy: [],
    foregroundCanopy: [],
  };
  className = "Tree";
  /**
   * Initializes everything for the tree to get busy with
   * @param p5 A reference to the p5 base class
   * @param x The x coordinate of the tree
   * @param y The y coordinate of the tree
   * @param scale The scale of the tree
   */
  constructor(p5, x, y, scale) {
    super(p5, x, y, scale ?? 1, { x: 70, y: 100, h: 100, w: 25 });
    // Randomize the tree's elements
    // We are doing this once, in the constructor. It'll just render
    // in the draw.
    this.randomizedElements = {
      backgroundCanopy: [
        {
          x: 50 + (this.randomInt(0, 40) - 20),
          y: 70 + (this.randomInt(0, 20) - 10),
          width: 100 + (this.randomInt(0, 40) - 20),
        },
        {
          x: 140 + (this.randomInt(0, 40) - 20),
          y: 80 + (this.randomInt(0, 20) - 10),
          width: 100 + (this.randomInt(0, 40) - 20),
        },
        {
          x: 80 + (this.randomInt(0, 40) - 20),
          y: 50 + (this.randomInt(0, 20) - 10),
          width: 100 + (this.randomInt(0, 40) - 20),
        },
      ],
      foregroundCanopy: [
        {
          x: 120 + (this.randomInt(0, 40) - 20),
          y: 45 + (this.randomInt(0, 20) - 10),
          width: 90 + (this.randomInt(0, 30) - 15),
        },
        {
          x: 95 + (this.randomInt(0, 40) - 20),
          y: 85 + (this.randomInt(0, 20) - 10),
          width: 90 + (this.randomInt(0, 30) - 15),
        },
        {
          x: 50 + (this.randomInt(0, 40) - 20),
          y: 50 + (this.randomInt(0, 20) - 10),
          width: 90 + (this.randomInt(0, 30) - 15),
        },
      ],
    };
  }
  /**
   * Draws tree
   */
  draw = () => {
    const { darkFoliage, foliageOutline, lightFoliage, lightBark, darkBark } =
      colors;
    const { backgroundCanopy, foregroundCanopy } = this.randomizedElements;
    // We pass the draw commands to the base class to render.
    // Why pass as an array? Because the sprite class will provide mathematic
    // computations to account for scale and position.
    this.processArray([
      ["fill", darkFoliage],
      ["stroke", foliageOutline],
      ["strokeWeight", 2],
      [
        "ellipse",
        backgroundCanopy[0].x,
        backgroundCanopy[0].y,
        backgroundCanopy[0].width,
        backgroundCanopy[0].width,
      ],
      [
        "ellipse",
        backgroundCanopy[1].x,
        backgroundCanopy[1].y,
        backgroundCanopy[1].width,
        backgroundCanopy[1].width,
      ],
      [
        "ellipse",
        backgroundCanopy[2].x,
        backgroundCanopy[2].y,
        backgroundCanopy[2].width,
        backgroundCanopy[2].width,
      ],
      ["noStroke"],
      ["fill", 0, 0, 0, 30],
      ["ellipse", 90, 200, 180, 10],
      ["noStroke"],
      ["noFill"],
      ["stroke", lightBark],
      ["strokeWeight", 15],
      ["arc", 70, 90, 50, 50, this.p5.PI / 4 + 0.57, this.p5.PI],
      ["stroke", darkBark],
      ["arc", 90, 90, 50, 50, this.p5.PI + 3.3, this.p5.PI / 4 + 0.57],
      ["noStroke"],
      ["fill", lightBark],
      ["rect", 70, 100, 10, 100],
      ["fill", darkBark],
      ["rect", 80, 100, 15, 100],
      ["stroke", foliageOutline],
      ["strokeWeight", 2],
      ["fill", lightFoliage],
      [
        "ellipse",
        foregroundCanopy[0].x,
        foregroundCanopy[0].y,
        foregroundCanopy[0].width,
        foregroundCanopy[0].width,
      ],
      [
        "ellipse",
        foregroundCanopy[1].x,
        foregroundCanopy[1].y,
        foregroundCanopy[1].width,
        foregroundCanopy[1].width,
      ],
      [
        "ellipse",
        foregroundCanopy[2].x,
        foregroundCanopy[2].y,
        foregroundCanopy[2].width,
        foregroundCanopy[2].width,
      ],
    ]);
  };
}

export function levelOne(p5) {
  const mountains = [
    new Mountain(p5, 465, 150, 6),
    new Mountain(p5, 665, 150, 6),
    new Mountain(p5, 865, 150, 6),
    new Mountain(p5, 2065, 150, 6),
    new Mountain(p5, 2265, 150, 6),
    new Mountain(p5, 2665, 150, 6),
    new Mountain(p5, 2865, 150, 6),
  ];
  const clouds = [
    new Cloud(p5, 600, 100, 0.75),
    new Cloud(p5, 1300, 100, 1),
    new Cloud(p5, 1800, 100, 0.55),
    new Cloud(p5, 1950, 100, 0.85),
    new Cloud(p5, 2500, 100, 1),
    new Cloud(p5, 2750, 100, 1.1),
  ];
  // Let's make one sad
  clouds[1].setMood(Mood.Sad, 100);
  clouds[5].setMood(Mood.Sad, 220);
  const canyons = [
    new Canyon(p5, 200, 432, 1, 50),
    new Canyon(p5, 1671.25, 432, 1, 30),
  ];
  canyons[1].setChanceForCreviceWidthChange(30);
  const collectables = [
    new Collectable(p5, 800, 400, 1),
    new Collectable(p5, 1100, 405, 1),
    new Collectable(p5, 1400, 370, 1),
    new Collectable(p5, 1800, 305, 1),
    new Collectable(p5, 2000, 340, 1),
    new Collectable(p5, 2200, 360, 1),
  ];
  const trees_x = [
    new Tree(p5, 700, 300, 1),
    new Tree(p5, 520, 310, 1),
    new Tree(p5, 850, 350, 1),
    new Tree(p5, 950, 305, 1),
    new Tree(p5, 972, 312, 1),
    new Tree(p5, 1015, 305, 1),
    new Tree(p5, 1315, 332, 1),
    new Tree(p5, 1329, 316, 1),
    new Tree(p5, 1420, 310, 1),
    new Tree(p5, 1850, 350, 1),
    new Tree(p5, 1950, 305, 1),
    new Tree(p5, 1972, 312, 1),
    new Tree(p5, 1915, 305, 1),
    new Tree(p5, 2315, 332, 1),
    new Tree(p5, 2429, 316, 1),
    new Tree(p5, 2529, 330, 1),
    new Tree(p5, 2629, 320, 1),
    new Tree(p5, 2689, 339, 1),
    new Tree(p5, 2709, 400, 1),
    new Tree(p5, 2809, 350, 1),
  ];
  return {
    mountains,
    clouds,
    canyons,
    collectables,
    trees_x,
  };
}

import * as React from "react";
import { ReactP5Wrapper } from "@p5-wrapper/react";

function sketch(p5) {
  const pieceOfPaper = new PieceOfPaper(p5, 520, 420, 0.5);
  /*
    All of our level data is stored in the levelOne function. We can destructure it,
    and use that.
  
    I choose to use this method so I can call more levels in the future.
     */
  const { trees_x, collectables, canyons, clouds, mountains } = levelOne(p5);
  /** Handles they key presses */
  p5.setup = () => {
    const canvas = p5.createCanvas(1024, 576);
    // Necessary for the canvas to be able to read pixel data at optimum speed
    canvas.canvas.getContext("2d", { willReadFrequently: true });
  };
  /** Handles key presses */
  p5.keyPressed = () => {
    pieceOfPaper.handleKeyPress();
  };
  /** Handles key releases */
  p5.keyReleased = () => {
    pieceOfPaper.handleKeyRelease();
  };
  /** Draw loop */
  p5.draw = () => {
    // Camera
    // Let's check for interactions
    pieceOfPaper.checkForInteraction(collectables);
    // Let's check for input
    pieceOfPaper.handleMovementAndOrientation();
    // Get our camera
    let cameraPosX = pieceOfPaper.getCameraAdjustedX();
    if (cameraPosX < 0) {
      cameraPosX = 0;
    }
    p5.background(colors.blueSky);
    p5.smooth();
    p5.noStroke();
    // Ground
    p5.fill(colors.grassGreen);
    p5.rect(0, 432, 1024, 144);
    p5.stroke(0);
    p5.strokeWeight(1);
    p5.line(0, 432, 1024, 432);
    // Render
    p5.push();
    p5.translate(-cameraPosX, 0);
    // This really should be a forEach, but the instructions asked for a for loop
    // While the for loop is a bit more performant, but the difference is negligible
    // and forEach is more readable.
    for (let i = 0; i < mountains.length; i++) {
      mountains[i].draw();
    }
    // This really should be a forEach, but the instructions asked for a for loop
    // While the for loop is a bit more performant, but the difference is negligible
    // and forEach is more readable.
    for (let i = 0; i < clouds.length; i++) {
      clouds[i].draw();
    }
    // Ok - here is how it should be done. I feel I can get away with this now
    // Since you didn't specify anything as regards to canyons
    canyons.forEach((canyon) => {
      canyon.draw();
    });
    // Let's get the trees, collectible, and piece of paper to render in a specific order
    const orderedRenders = [...trees_x, ...collectables, pieceOfPaper].sort(
      (a, b) => {
        let firstY =
          a instanceof PieceOfPaper ? a.getCalculatedY() : a.getBottomY();
        let secondY =
          b instanceof PieceOfPaper ? b.getCalculatedY() : b.getBottomY();
        return firstY - secondY;
      },
    );
    // Render them in order, so objects further away than the character are rendered
    // behind him
    // This should be done with a forEach on the array - the built in iterator.
    // But the course asked for a for loop, so here it is.
    for (let i = 0; i < orderedRenders.length; i++) {
      if (orderedRenders[i] instanceof PieceOfPaper) {
        orderedRenders[i].draw();
      } else {
        orderedRenders[i].draw();
      }
    }
    p5.pop();
  };
}
/**
 * expects the game as a React component
 * @constructor
 */
export const SideScroller = () =>
  React.createElement(
    React.Fragment,
    null,
    React.createElement(ReactP5Wrapper, { sketch: sketch }),
  );

/*
  Notes for whomever reviews this code:
  I'm using Redux to manage global state. I freakin' love redux.

  Redux eases debugging, centralizes all state, scales well, is easy to test
  and is wicked, wicked cool.

  Right now this is kind of empty, because we aren't at the point yet where i
  need to manage lives, score, etc. But when we get there, this is where it will
  all be managed
 */
export {};

/*
 * See note in global-state
 */
export const projectSlice = createSlice({
  name: "project",
  initialState: {
    value: "SideScroller",
  },
  reducers: {
    changeProject: (state, action) => {
      return { ...state, value: action.payload };
    },
  },
});
export function selectProject(state) {
  return state.project.value;
}
export const { changeProject } = projectSlice.actions;
export default projectSlice.reducer;

/*
See the comments in ./global-state.ts
 */
export const store = configureStore({
  reducer: {
    project: projectReducer,
  },
});
