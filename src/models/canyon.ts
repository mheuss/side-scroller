import { Sprite } from "src/models/sprite";
import { P5CanvasInstance } from "@p5-wrapper/react";
import { colors } from "src/constants";

/*
  The below is autogenerated from the code.

The provided code defines a `Canyon` class in TypeScript that extends the `Sprite` class. This class represents a canyon that a player must jump over within a p5.js-based graphical environment. The canyon can animate by varying its width over time.

Key components of the code:

- **Constants**:
  - `MAX_WIDTH`: Maximum width of the canyon.
  - `MIN_WIDTH`: Minimum width of the canyon.

- **Interface**:
  - `ICrevice`: Specifies the properties of the canyon's crevice width, velocity of width change, and the chance for the width to change.

- **Class Definition**:
  - **Properties**:
    - `crevice`: An object adhering to `ICrevice`, managing the canyon's width, velocity, and change probability.
    - `className`: Identifier for checking interactions, set to "Canyon".

  - **Constructor**: Initializes the canyon with position, scale, and initial width of the crevice, constraining the width between `MIN_WIDTH` and `MAX_WIDTH`.

- **Methods**:
  - **Public Methods**:
    - `setChanceForCreviceWidthChange`: Sets the probability (as a percentage) that the crevice width will change during each draw cycle.
    - `draw`: Main rendering function for the canyon, which also handles potential animation of the canyon's width.

  - **Private Methods**:
    - `shouldCreviceChange`: Determines if the crevice width should change based on the set probability and, if so, updates the width and velocity accordingly. It ensures that the width stays within the defined bounds (`MIN_WIDTH` to `MAX_WIDTH`).

- **Drawing Instructions**:
  - In the `draw` method, various p5.js drawing commands are executed to render both halves of the canyon. The rendering accounts for the width of the crevice and includes drawing the horizon line, filling shapes, and drawing vertices that make up the visual representation of the canyon.

The `Canyon` class extends the functionality of the base `Sprite` class to include dynamic changes to its width, adding an interactive and potentially challenging element to the game environment. The use of p5.js commands within `processArray` enables the dynamic and visually accurate rendering of complex shapes that represent the canyon.
 */

/*
Since i want the width of the canyon to vary, and even to animate opening and closing
at different times, I need to set a max and min width size.
 */
const MAX_WIDTH = 70;
const MIN_WIDTH = 0;

/*
  Interface for the crevice - to keep track of properties pertaining to this
  character.
*/
interface ICrevice {
  width: number; // How wide of a gap is the canyon
  velocity: number; // If the canyon is opening and/or closing, what is the velocity
  chanceForChange: number; // What is the chance the canyon is going to change width
}

/**
 * This class represents the canyon that the player will have to jump over.
 */
export class Canyon extends Sprite {
  private crevice: ICrevice; // Width or spread of the chasm
  public className = "Canyon"; // Used for reference when checking for interactions

  /**
   * Initializes the canyon with the given properties.
   * @param p5 - The p5 instance
   * @param x - The x position
   * @param y - The y position
   * @param scale - The scale of the canyon
   * @param crevice - The width of the canyon
   */
  constructor(
    p5: P5CanvasInstance,
    x: number,
    y: number,
    scale: number,
    crevice: number = 0,
  ) {
    super(p5, x, y, scale ?? 1);

    // Default props
    this.crevice = {
      width: p5.constrain(crevice, MIN_WIDTH, MAX_WIDTH),
      velocity: 0,
      chanceForChange: 0,
    };
  }

  /**
   * When set to a number be 1 and 100, reflects the chance of the crevice width
   * changing during the draw cycle.
   *
   * The speed of the change is random
   * @param chance
   */
  public setChanceForCreviceWidthChange = (chance: number) => {
    this.crevice.chanceForChange = chance;
  };

  /**
   * Private function that will determine if the crevice width should change.
   * If it decides it should, it'll randomly change the velocity of the crevice
   * If the crevice was changing, it could stop.
   */
  private shouldCreviceChange = () => {
    const { crevice } = this;

    if (!crevice.velocity) {
      const rolledPercent = this.randomInt(0, 100);

      if (rolledPercent < crevice.chanceForChange) {
        crevice.velocity = (this.randomInt(0, 6) - 2) / 2;
      }
    }

    if (crevice.velocity === 0) {
      return;
    }

    crevice.width += crevice.velocity;

    if (crevice.width >= MAX_WIDTH) {
      crevice.velocity = 0;
      crevice.width = MAX_WIDTH;
    } else if (crevice.width <= MIN_WIDTH) {
      crevice.velocity = 0;
      crevice.width = MIN_WIDTH;
    }
  };

  /**
   * Main draw function.
   */
  public draw() {
    const { blueSky, grassGreen, darkerGray, midGray, stoneGray } = colors;
    const { crevice } = this;

    // Check if we are applying animation to this canyon, and if so, animate it.
    this.shouldCreviceChange();

    // We pass the draw commands to the base class to render.
    // Why pass as an array? Because the sprite class will provide mathematic
    // computations to account for scale and position.
    this.processArray([
      // First Spread
      ["stroke", blueSky],
      ["strokeWeight", 1],
      ["noFill"],
      ["line", 0, 0, 158 + crevice.width, 0], //draw a horizon line
      ["noStroke"],
      ["fill", blueSky],
      ["rect", 2, -1, 158 + crevice.width, 200],
      ["fill", darkerGray],
      ["noStroke"],
      ["beginShape"],
      ["vertex", 2, 0],
      ["vertex", 70, 20],
      ["vertex", 50, 150],
      ["vertex", 2, 150],
      ["endShape", this.p5.CLOSE],
      ["fill", midGray],
      ["beginShape"],
      ["vertex", 50, 80],
      ["vertex", 90, 80],
      ["vertex", 50, 210],
      ["endShape", this.p5.CLOSE],
      ["strokeWeight", 1],
      ["fill", grassGreen],
      ["beginShape"],
      ["vertex", 10, 0],
      ["vertex", 15, 0],
      ["vertex", 20, 0],
      ["curveVertex", 40, 5],
      ["curveVertex", 70, 20],
      ["curveVertex", 30, 45],
      ["curveVertex", 90, 75],
      ["curveVertex", 70, 95],
      ["curveVertex", 30, 110],
      ["vertex", 90, 130],
      ["vertex", 15, 200],
      ["endShape", this.p5.CLOSE],
      ["rect", 0, 0, 11, 200],
      ["rect", 158 + crevice.width, 0, 5, 200],
      // Second Half
      ["fill", stoneGray],
      [
        "quad",
        100 + crevice.width,
        10,
        150 + crevice.width,
        100,
        150 + crevice.width,
        140,
        150 + crevice.width,
        10,
      ],
      ["fill", midGray],
      [
        "quad",
        100 + crevice.width,
        100,
        150 + crevice.width,
        150,
        150 + crevice.width,
        170,
        150 + crevice.width,
        100,
      ],
      ["fill", grassGreen],
      ["beginShape"],
      ["vertex", 160 + crevice.width, 0],
      ["curveVertex", 130 + crevice.width, 0],
      ["curveVertex", 100 + crevice.width, 10],
      ["curveVertex", 130 + crevice.width, 35],
      ["curveVertex", 100 + crevice.width, 10],
      ["curveVertex", 130 + crevice.width, 35],
      ["curveVertex", 140 + crevice.width, 80],
      ["curveVertex", 100 + crevice.width, 100],
      ["vertex", 145 + crevice.width, 120],
      ["vertex", 160 + crevice.width, 200],
      ["endShape", this.p5.CLOSE],
      ["noStroke"],
      ["stroke", 0],
      ["strokeWeight", 0.5],
      ["line", 0, 0, 20, 0],
      ["line", 128 + crevice.width, 0, 200 + crevice.width, 0],
    ]);
  }
}
